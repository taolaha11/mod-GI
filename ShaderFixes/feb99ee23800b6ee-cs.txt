//
// Generated by Microsoft (R) D3D Shader Disassembler
//
//   using 3Dmigoto v1.3.16 on Mon Mar  3 19:03:28 2025
//
//
// Input signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// no Input
//
// Output signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// no Output
cs_5_0
dcl_globalFlags refactoringAllowed
dcl_constantbuffer CB0[26], immediateIndexed
dcl_constantbuffer CB1[6], immediateIndexed
dcl_constantbuffer CB2[57], dynamicIndexed
dcl_sampler s0, mode_comparison
dcl_resource_texture2d (float,float,float,float) t0
dcl_resource_texture2d (float,float,float,float) t1
dcl_resource_texture2d (float,float,float,float) t2
dcl_uav_typed_texture2d (uint,uint,uint,uint) u0
dcl_uav_structured u1, 4
dcl_uav_structured u2, 4
dcl_input vThreadIDInGroupFlattened
dcl_input vThreadGroupID.xy
dcl_temps 5
dcl_indexableTemp x0[2], 4
dcl_tgsm_structured g0, 4, 2
dcl_tgsm_structured g1, 4, 64
dcl_tgsm_structured g2, 4, 64
dcl_thread_group 64, 1, 1
imad r0.x, vThreadGroupID.x, l(64), vThreadIDInGroupFlattened.x
mov r0.y, vThreadGroupID.y
mov r0.zw, l(0,0,0,0)
ld_indexable(texture2d)(float,float,float,float) r1.xy, r0.xyww, t1.xyzw
lt r1.zw, |r1.xxxy|, l(0.000000, 0.000000, 1.000100, 1.000100)
and r1.z, r1.w, r1.z
ult r1.w, vThreadIDInGroupFlattened.x, l(2)
if_nz r1.w
  store_structured g0.x, vThreadIDInGroupFlattened.x, l(0), l(0)
  store_structured g2.x, vThreadIDInGroupFlattened.x, l(0), l(0)
endif
sync_g_t
if_nz r1.z
  ld_indexable(texture2d)(float,float,float,float) r0.z, r0.xyzw, t2.yzxw
  min r0.w, r0.z, l(64.000000)
  store_structured g1.x, vThreadIDInGroupFlattened.x, l(0), r0.w
  mul r2.xyzw, r1.yyyy, cb0[10].xyzw
  mad r2.xyzw, cb0[9].xyzw, r1.xxxx, r2.xyzw
  add r2.xyzw, r2.xyzw, cb0[11].xyzw
  add r2.xyzw, r2.xyzw, cb0[12].xyzw
  div r1.xyw, r2.xyxz, r2.wwww
  add r1.xyw, r1.xyxw, -cb1[5].xyxz
  dp3 r0.w, r1.xywx, r1.xywx
  rsq r0.w, r0.w
  mul r1.xyw, r0.wwww, r1.xyxw
  mul r0.w, r1.y, cb0[6].z
  mad r0.w, cb0[5].z, r1.x, r0.w
  mad r0.w, cb0[7].z, r1.w, r0.w
  div r0.z, r0.z, r0.w
  add r0.z, |r0.z|, l(-0.010000)
  max r0.z, r0.z, l(0.000000)
  mad r2.xyz, r1.xywx, r0.zzzz, cb1[5].xyzx
  dp3 r0.z, r1.xywx, cb0[4].xyzx
  mov r0.w, l(1.000000)
  mov r1.x, l(0)
  loop
    ieq r1.y, r1.x, l(6)
    breakc_nz r1.y
    add r3.xyz, r2.xyzx, -cb2[r1.x + 0].xyzx
    dp3 r1.y, r3.xyzx, r3.xyzx
    lt r1.y, r1.y, cb2[r1.x + 0].w
    if_nz r1.y
      add r3.xyz, r2.xyzx, -cb2[r1.x + 49].xyzx
      ishl r1.y, r1.x, l(2)
      mul r4.xyzw, r3.yyyy, cb2[r1.y + 16].xyzw
      mad r4.xyzw, cb2[r1.y + 15].xyzw, r3.xxxx, r4.xyzw
      mad r3.xyzw, cb2[r1.y + 17].xyzw, r3.zzzz, r4.xyzw
      add r3.xyzw, r3.xyzw, cb2[r1.y + 18].xyzw
      div r3.xyz, r3.xyzx, r3.wwww
      sample_c_lz_indexable(texture2d)(float,float,float,float) r0.w, r3.xyxx, t0.xxxx, s0, r3.z
      break
    endif
    iadd r1.x, r1.x, l(1)
    mov r0.w, l(1.000000)
  endloop
  ushr r1.x, vThreadIDInGroupFlattened.x, l(5)
  lt r0.zw, l(0.000000, 0.000000, 0.999847710, 0.000000), r0.zzzw
  bfi r0.w, l(1), vThreadIDInGroupFlattened.x, r0.w, l(0)
  mov r1.y, l(0)
  atomic_or g2, r1.xyxx, r0.w
else
  mov r0.z, l(0)
endif
sync_g_t
if_nz r1.z
  ine r0.w, vThreadIDInGroupFlattened.x, l(63)
  if_nz r0.w
    ld_structured r0.w, vThreadIDInGroupFlattened.x, l(0), g1.xxxx
    iadd r1.x, vThreadIDInGroupFlattened.x, l(1)
    ld_structured r1.y, r1.x, l(0), g1.xxxx
    ushr r1.w, vThreadIDInGroupFlattened.x, l(5)
    ld_structured r1.w, r1.w, l(0), g2.xxxx
    ushr r1.w, r1.w, vThreadIDInGroupFlattened.x
    ushr r2.x, r1.x, l(5)
    ld_structured r2.x, r2.x, l(0), g2.xxxx
    ushr r1.x, r2.x, r1.x
    and r1.xw, r1.xxxw, l(1, 0, 0, 1)
    max r2.x, r0.w, r1.y
    max r2.x, r2.x, l(0.000010)
    ieq r1.x, r1.x, r1.w
    add r0.w, r0.w, -r1.y
    div r0.w, |r0.w|, r2.x
    lt r0.w, r0.w, cb0[25].x
    and r0.w, r1.x, r0.w
    not r0.z, r0.z
    and r0.z, r0.z, r0.w
    and r0.z, r0.z, l(1)
  else
    mov r0.z, l(0)
  endif
  ushr r1.x, vThreadIDInGroupFlattened.x, l(5)
  ishl r0.z, r0.z, vThreadIDInGroupFlattened.x
  mov r1.y, l(0)
  atomic_or g0, r1.xyxx, r0.z
endif
sync_g_t
if_z r1.z
  store_uav_typed u0.xyzw, r0.xyyy, l(-1,-1,-1,-1)
  ret
endif
ishl r0.z, vThreadGroupID.x, l(6)
and r1.x, vThreadIDInGroupFlattened.x, l(32)
iadd r0.w, r1.x, l(32)
resinfo_indexable(texture2d)(uint,uint,uint,uint)_uint r1.z, l(0), u0.yzxw
ushr r1.z, r1.z, l(6)
iadd r1.z, r1.z, l(-1)
ieq r1.z, r1.z, vThreadGroupID.x
umin r1.w, r0.w, l(63)
movc r1.y, r1.z, r1.w, r0.w
ult r0.w, r1.x, vThreadIDInGroupFlattened.x
ult r1.z, vThreadIDInGroupFlattened.x, r1.y
and r0.w, r0.w, r1.z
if_nz r0.w
  ld_structured r0.w, l(0), l(0), g0.xxxx
  mov x0[0].x, r0.w
  ld_structured r1.z, l(1), l(0), g0.xxxx
  mov x0[1].x, r1.z
  ieq r0.w, r0.w, l(-1)
  ine r1.z, r1.z, l(-1)
  movc r0.w, r1.z, l(0), r0.w
  if_z r0.w
    ushr r0.w, vThreadIDInGroupFlattened.x, l(5)
    iadd r1.z, vThreadIDInGroupFlattened.x, l(-1)
    ushr r1.w, r1.z, l(5)
    and r2.x, r1.z, l(31)
    mov r1.w, x0[r1.w + 0].x
    ult r2.y, r2.x, l(31)
    iadd r2.z, r2.x, l(1)
    ishl r2.z, l(-1), r2.z
    or r2.z, r1.w, r2.z
    movc r1.w, r2.y, r2.z, r1.w
    not r1.w, r1.w
    firstbit_hi r2.y, r1.w
    iadd r2.y, -r2.y, l(31)
    movc r1.w, r1.w, r2.y, l(-1)
    ige r2.y, r1.w, l(0)
    ilt r2.z, r1.w, l(32)
    and r2.y, r2.z, r2.y
    movc r1.w, r2.y, r1.w, l(-1)
    iadd r1.w, r1.w, -r2.x
    iadd r1.z, r1.w, r1.z
    iadd r1.z, r1.z, l(1)
    umax r1.x, r1.x, r1.z
    and r1.z, vThreadIDInGroupFlattened.x, l(31)
    mov r0.w, x0[r0.w + 0].x
    ilt r1.w, l(0), r1.z
    bfi r2.x, vThreadIDInGroupFlattened.x, l(0), l(-1), r0.w
    movc r0.w, r1.w, r2.x, r0.w
    not r0.w, r0.w
    firstbit_lo r0.w, r0.w
    ige r1.w, r0.w, l(0)
    movc r0.w, r1.w, r0.w, l(32)
    iadd r0.w, -r1.z, r0.w
    iadd r0.w, r0.w, vThreadIDInGroupFlattened.x
    umin r1.y, r1.y, r0.w
  endif
  ieq r1.zw, r1.xxxy, vThreadIDInGroupFlattened.xxxx
  or r0.w, r1.w, r1.z
  movc r1.xy, r0.wwww, vThreadIDInGroupFlattened.xxxx, r1.xyxx
else
  mov r1.xy, vThreadIDInGroupFlattened.xxxx
endif
iadd r0.zw, r0.zzzz, r1.xxxy
ishl r0.w, r0.w, l(16)
or r0.z, r0.z, r0.w
store_uav_typed u0.xyzw, r0.xyyy, r0.zzzz
ieq r0.y, r1.y, r1.x
if_nz r0.y
  imm_atomic_iadd r1.x, u1, l(0, 0, 0, 0), l(1)
  ishl r0.y, vThreadGroupID.y, l(16)
  or r0.x, r0.x, r0.y
  store_structured u2.x, r1.x, l(0), r0.x
endif
ret
// Approximately 0 instruction slots used

///////////////////////////////// HLSL Code /////////////////////////////////
// // ---- Created with 3Dmigoto v1.3.16 on Mon Mar  3 19:03:28 2025
// groupshared struct { float val[1]; } g2[64];
// groupshared struct { float val[1]; } g1[64];
// groupshared struct { float val[1]; } g0[2];
// struct u2_t {
//   float val[1];
// };
// RWStructuredBuffer<u2_t> u2 : register(u2);
//
// struct u1_t {
//   float val[1];
// };
// RWStructuredBuffer<u1_t> u1 : register(u1);
//
// Texture2D<float4> t2 : register(t2);
//
// Texture2D<float4> t1 : register(t1);
//
// Texture2D<float4> t0 : register(t0);
//
// SamplerComparisonState s0_s : register(s0);
//
// cbuffer cb2 : register(b2)
// {
//   float4 cb2[57];
// }
//
// cbuffer cb1 : register(b1)
// {
//   float4 cb1[6];
// }
//
// cbuffer cb0 : register(b0)
// {
//   float4 cb0[26];
// }
//
//
//
//
// // 3Dmigoto declarations
// #define cmp -
// Texture1D<float4> IniParams : register(t120);
// Texture2D<float4> StereoParams : register(t125);
//
//
// void main)
// {
// // Needs manual fix for instruction:
// // unknown dcl_: dcl_uav_typed_texture2d (uint,uint,uint,uint) u0
//   float4 r0,r1,r2,r3,r4;
//   uint4 bitmask, uiDest;
//   float4 fDest;
//
//   float4 x0[2];
// // Needs manual fix for instruction:
// // unknown dcl_: dcl_thread_group 64, 1, 1
//   r0.x = mad((int)vThreadGroupID.x, 64, (int)vThreadIDInGroupFlattened.x);
//   r0.y = vThreadGroupID.y;
//   r0.zw = float2(0,0);
//   r1.xy = t1.Load(r0.xyw).xy;
//   r1.zw = cmp(abs(r1.xy) < float2(1.00010002,1.00010002));
//   r1.z = r1.w ? r1.z : 0;
//   r1.w = cmp((uint)vThreadIDInGroupFlattened.x < 2);
//   if (r1.w != 0) {
//     g0[vThreadIDInGroupFlattened.x].val[0/4] = 0;
//     g2[vThreadIDInGroupFlattened.x].val[0/4] = 0;
//   }
//   GroupMemoryBarrierWithGroupSync();
//   if (r1.z != 0) {
//     r0.z = t2.Load(r0.xyz).x;
//     r0.w = min(64, r0.z);
//     g1[vThreadIDInGroupFlattened.x].val[0/4] = r0.w;
//     r2.xyzw = cb0[10].xyzw * r1.yyyy;
//     r2.xyzw = cb0[9].xyzw * r1.xxxx + r2.xyzw;
//     r2.xyzw = cb0[11].xyzw + r2.xyzw;
//     r2.xyzw = cb0[12].xyzw + r2.xyzw;
//     r1.xyw = r2.xyz / r2.www;
//     r1.xyw = -cb1[5].xyz + r1.xyw;
//     r0.w = dot(r1.xyw, r1.xyw);
//     r0.w = rsqrt(r0.w);
//     r1.xyw = r1.xyw * r0.www;
//     r0.w = cb0[6].z * r1.y;
//     r0.w = cb0[5].z * r1.x + r0.w;
//     r0.w = cb0[7].z * r1.w + r0.w;
//     r0.z = r0.z / r0.w;
//     r0.z = -0.00999999978 + abs(r0.z);
//     r0.z = max(0, r0.z);
//     r2.xyz = r1.xyw * r0.zzz + cb1[5].xyz;
//     r0.z = dot(r1.xyw, cb0[4].xyz);
//     r0.w = 1;
//     r1.x = 0;
//     while (true) {
//       r1.y = cmp((int)r1.x == 6);
//       if (r1.y != 0) break;
//       r3.xyz = -cb2[r1.x+0].xyz + r2.xyz;
//       r1.y = dot(r3.xyz, r3.xyz);
//       r1.y = cmp(r1.y < cb2[r1.x+0].w);
//       if (r1.y != 0) {
//         r3.xyz = -cb2[r1.x+49].xyz + r2.xyz;
//         r1.y = (uint)r1.x << 2;
//         r4.xyzw = cb2[r1.y+16].xyzw * r3.yyyy;
//         r4.xyzw = cb2[r1.y+15].xyzw * r3.xxxx + r4.xyzw;
//         r3.xyzw = cb2[r1.y+17].xyzw * r3.zzzz + r4.xyzw;
//         r3.xyzw = cb2[r1.y+18].xyzw + r3.xyzw;
//         r3.xyz = r3.xyz / r3.www;
//         r0.w = t0.SampleCmpLevelZero(s0_s, r3.xy, r3.z).x;
//         break;
//       }
//       r1.x = (int)r1.x + 1;
//       r0.w = 1;
//     }
//     r1.x = (uint)vThreadIDInGroupFlattened.x >> 5;
//     r0.zw = cmp(float2(0.99984771,0) < r0.zw);
//     bitmask.w = ((~(-1 << 1)) << vThreadIDInGroupFlattened.x) & 0xffffffff;  r0.w = (((uint)r0.w << vThreadIDInGroupFlattened.x) & bitmask.w) | ((uint)0 & ~bitmask.w);
//     r1.y = 0;
//     // Needs manual fix for instruction:
//     atomic_or g2, r1.xyxx, r0.w
//     InterlockedOr(dest, value, orig_value);
//   } else {
//     r0.z = 0;
//   }
//   GroupMemoryBarrierWithGroupSync();
//   if (r1.z != 0) {
//     r0.w = cmp((int)vThreadIDInGroupFlattened.x != 63);
//     if (r0.w != 0) {
//       r0.w = g1[vThreadIDInGroupFlattened.x].val[0/4];
//       r1.x = (int)vThreadIDInGroupFlattened.x + 1;
//       r1.y = g1[r1.x].val[0/4];
//       r1.w = (uint)vThreadIDInGroupFlattened.x >> 5;
//       r1.w = g2[r1.w].val[0/4];
//       r1.w = (uint)r1.w >> (uint)vThreadIDInGroupFlattened.x;
//       r2.x = (uint)r1.x >> 5;
//       r2.x = g2[r2.x].val[0/4];
//       r1.x = (uint)r2.x >> (uint)r1.x;
//       r1.xw = (int2)r1.xw & int2(1,1);
//       r2.x = max(r1.y, r0.w);
//       r2.x = max(9.99999975e-06, r2.x);
//       r1.x = cmp((int)r1.x == (int)r1.w);
//       r0.w = -r1.y + r0.w;
//       r0.w = abs(r0.w) / r2.x;
//       r0.w = cmp(r0.w < cb0[25].x);
//       r0.w = r1.x ? r0.w : 0;
//       r0.z = ~(int)r0.z;
//       r0.z = r0.w ? r0.z : 0;
//       r0.z = (int)r0.z & 1;
//     } else {
//       r0.z = 0;
//     }
//     r1.x = (uint)vThreadIDInGroupFlattened.x >> 5;
//     r0.z = (uint)r0.z << (int)vThreadIDInGroupFlattened.x;
//     r1.y = 0;
//     // Needs manual fix for instruction:
//     atomic_or g0, r1.xyxx, r0.z
//     InterlockedOr(dest, value, orig_value);
//   }
//   GroupMemoryBarrierWithGroupSync();
//   if (r1.z == 0) {
//   // No code for instruction (needs manual fix):
//     store_uav_typed u0.xyzw, r0.xyyy, l(-1,-1,-1,-1)
//     return;
//   }
//   r0.z = (uint)vThreadGroupID.x << 6;
//   r1.x = (int)vThreadIDInGroupFlattened.x & 32;
//   r0.w = (int)r1.x + 32;
//   u0.GetDimensions(0, uiDest.x, uiDest.y, uiDest.z);
//   r1.z = uiDest.x;
//   r1.z = (uint)r1.z >> 6;
//   r1.z = (int)r1.z + -1;
//   r1.z = cmp((int)r1.z == (int)vThreadGroupID.x);
//   r1.w = min(63, (uint)r0.w);
//   r1.y = r1.z ? r1.w : r0.w;
//   r0.w = cmp((uint)r1.x < (uint)vThreadIDInGroupFlattened.x);
//   r1.z = cmp((uint)vThreadIDInGroupFlattened.x < (uint)r1.y);
//   r0.w = r0.w ? r1.z : 0;
//   if (r0.w != 0) {
//     r0.w = g0[0].val[0/4];
//     x0[0].x = r0.w;
//     r1.z = g0[1].val[0/4];
//     x0[1].x = r1.z;
//     r0.w = cmp((int)r0.w == -1);
//     r1.z = cmp((int)r1.z != -1);
//     r0.w = r1.z ? 0 : r0.w;
//     if (r0.w == 0) {
//       r0.w = (uint)vThreadIDInGroupFlattened.x >> 5;
//       r1.z = (int)vThreadIDInGroupFlattened.x + -1;
//       r1.w = (uint)r1.z >> 5;
//       r2.x = (int)r1.z & 31;
//       r1.w = x0[r1.w+0].x;
//       r2.y = cmp((uint)r2.x < 31);
//       r2.z = (int)r2.x + 1;
//       r2.z = -1 << (int)r2.z;
//       r2.z = (int)r1.w | (int)r2.z;
//       r1.w = r2.y ? r2.z : r1.w;
//       r1.w = ~(int)r1.w;
//       r2.y = firstbithigh((uint)r1.w);
//       r2.y = (int)-r2.y + 31;
//       r1.w = r1.w ? r2.y : -1;
//       r2.y = cmp((int)r1.w >= 0);
//       r2.z = cmp((int)r1.w < 32);
//       r2.y = r2.z ? r2.y : 0;
//       r1.w = r2.y ? r1.w : -1;
//       r1.w = (int)r1.w + (int)-r2.x;
//       r1.z = (int)r1.w + (int)r1.z;
//       r1.z = (int)r1.z + 1;
//       r1.x = max((uint)r1.z, (uint)r1.x);
//       r1.z = (int)vThreadIDInGroupFlattened.x & 31;
//       r0.w = x0[r0.w+0].x;
//       r1.w = cmp(0 < (int)r1.z);
//       bitmask.x = ((~(-1 << vThreadIDInGroupFlattened.x)) << 0) & 0xffffffff;  r2.x = (((uint)-1 << 0) & bitmask.x) | ((uint)r0.w & ~bitmask.x);
//       r0.w = r1.w ? r2.x : r0.w;
//       r0.w = ~(int)r0.w;
//       r0.w = firstbitlow((uint)r0.w);
//       r1.w = cmp((int)r0.w >= 0);
//       r0.w = r1.w ? r0.w : 32;
//       r0.w = (int)-r1.z + (int)r0.w;
//       r0.w = (int)r0.w + (int)vThreadIDInGroupFlattened.x;
//       r1.y = min((uint)r0.w, (uint)r1.y);
//     }
//     r1.zw = cmp((int2)r1.xy == (int2)vThreadIDInGroupFlattened.xx);
//     r0.w = (int)r1.w | (int)r1.z;
//     r1.xy = r0.ww ? vThreadIDInGroupFlattened.xx : r1.xy;
//   } else {
//     r1.xy = vThreadIDInGroupFlattened.xx;
//   }
//   r0.zw = (int2)r0.zz + (int2)r1.xy;
//   r0.w = (uint)r0.w << 16;
//   r0.z = (int)r0.z | (int)r0.w;
// // No code for instruction (needs manual fix):
// store_uav_typed u0.xyzw, r0.xyyy, r0.zzzz
//   r0.y = cmp((int)r1.y == (int)r1.x);
//   if (r0.y != 0) {
//     // Needs manual fix for instruction:
//     imm_atomic_iadd r1.x, u1, l(0, 0, 0, 0), l(1)
//     InterlockedAdd(dest, imm_value, orig_value);
//     r0.y = (uint)vThreadGroupID.y << 16;
//     r0.x = (int)r0.x | (int)r0.y;
//     u2[r1.x].val[0/4] = r0.x;
//   }
//   return;
// }
//////////////////////////////// HLSL Errors ////////////////////////////////
// C:\Users\PC\Desktop\3dmigoto GIMI (for playing mods)\3dmigoto\ShaderFixes\feb99ee23800b6ee-cs_replace.txt(47,10): error X3000: syntax error: unexpected token ')'
/////////////////////////////////////////////////////////////////////////////
